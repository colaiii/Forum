{% extends "base.html" %}

{% block title %}{{ thread.title }} - æ ¡å›­ç½‘åŒ¿åè®ºå›{% endblock %}

{% block content %}
<div class="thread-nav">
    <a href="{{ url_for('main.index') }}" class="btn btn-back">â¬… è¿”å›é¦–é¡µ</a>
</div>

<!-- ä¸»ä¸² -->
<div class="main-thread">
    <div class="thread-header">
        <span class="thread-id">No.{{ thread.id }}</span>
        {% if thread.is_pinned %}
        <span class="thread-pin">ğŸ“Œ</span>
        {% endif %}
        <span class="thread-cookie" style="color: {{ cookie_manager.get_cookie_color(thread.cookie_id) }}">
            {{ cookie_manager.format_cookie_display(thread.cookie_id) }}
        </span>
        <span class="thread-time">{{ thread.created_at.strftime('%Y-%m-%d %H:%M:%S') }}</span>
    </div>
    
    <h2 class="thread-title">{{ thread.title }}</h2>
    
    <div class="thread-content">
        {% if thread.image_url %}
        <div class="thread-image">
            <img src="{{ thread.image_url }}" alt="å›¾ç‰‡" onclick="showImageModal(this.src)">
        </div>
        {% endif %}
                    <div class="content-text markdown-content">{{ thread.content|markdown }}</div>
    </div>
    
    <div class="thread-actions">
        <button class="btn btn-reply" onclick="showReplyForm()">å›å¤</button>
        <span class="reply-count">ğŸ’¬ {{ thread.reply_count }} ä¸ªå›å¤</span>
    </div>
</div>

<!-- å›å¤è¡¨å• -->
<div id="replyForm" class="reply-form" style="display: none;">
    <h3>å‘è¡¨å›å¤</h3>
    <form id="submitReplyForm" enctype="multipart/form-data">
        <div class="form-group">
            <label for="replyContent">å†…å®¹:</label>
            <textarea id="replyContent" name="content" rows="6" placeholder="è¾“å…¥å›å¤å†…å®¹..." required></textarea>
        </div>
        
        <div class="form-group">
            <label for="replyImage">å›¾ç‰‡ (å¯é€‰):</label>
            <input type="file" id="replyImage" name="image" accept="image/*">
            <div class="image-preview" id="replyImagePreview"></div>
        </div>
        
        <input type="hidden" id="quoteId" name="quote_id" value="">
        
        <div class="form-actions">
            <button type="submit" class="btn btn-primary">å‘è¡¨å›å¤</button>
            <button type="button" class="btn btn-secondary" onclick="hideReplyForm()">å–æ¶ˆ</button>
        </div>
    </form>
</div>

<!-- æ–°å›å¤æç¤º -->
<div id="newRepliesNotification" class="new-threads-notification" style="display: none;">
    <span id="newRepliesMessage">ğŸ’¬ æœ‰æ–°å›å¤ï¼Œç‚¹å‡»æŸ¥çœ‹</span>
    <button onclick="refreshReplies(true)" class="refresh-btn">ç«‹å³æŸ¥çœ‹</button>
</div>

<!-- å›å¤åˆ—è¡¨ -->
<div class="replies-section">
    <div id="repliesList">
    {% for reply in replies %}
    <div class="reply-item" id="reply-{{ reply.id }}">
        <div class="reply-header">
            <span class="reply-id">No.{{ reply.id }}</span>
            <span class="reply-cookie" style="color: {{ cookie_manager.get_cookie_color(reply.cookie_id) }}">
                {{ cookie_manager.format_cookie_display(reply.cookie_id) }}
            </span>
            <span class="reply-time">{{ reply.created_at.strftime('%Y-%m-%d %H:%M:%S') }}</span>
            <button class="btn btn-quote" onclick="quoteReply({{ reply.id }}, '{{ cookie_manager.format_cookie_display(reply.cookie_id) }}')">å¼•ç”¨</button>
        </div>
        
        {% if reply.quote_id and reply.quoted_reply %}
        <div class="quote-block">
            <div class="quote-header">
                <span class="quote-id">å¼•ç”¨ No.{{ reply.quote_id }}</span>
                <span class="quote-cookie" style="color: {{ cookie_manager.get_cookie_color(reply.quoted_reply.cookie_id) }}">
                    {{ cookie_manager.format_cookie_display(reply.quoted_reply.cookie_id) }}
                </span>
            </div>
            <div class="quote-content">
                {{ reply.quoted_reply.content[:100] }}{% if reply.quoted_reply.content|length > 100 %}...{% endif %}
            </div>
        </div>
        {% endif %}
        
        <div class="reply-content">
            {% if reply.image_url %}
            <div class="reply-image">
                <img src="{{ reply.image_url }}" alt="å›¾ç‰‡" onclick="showImageModal(this.src)">
            </div>
            {% endif %}
                            <div class="content-text markdown-content">{{ reply.content|markdown }}</div>
        </div>
    </div>
    {% endfor %}
    </div>
</div>

<!-- å›¾ç‰‡å¼¹çª— -->
<div id="imageModal" class="modal" onclick="hideImageModal()">
    <div class="modal-content">
        <img id="modalImage" src="" alt="å›¾ç‰‡">
        <span class="modal-close">&times;</span>
    </div>
</div>

<script>
// æ˜¾ç¤ºå›å¤è¡¨å•
function showReplyForm() {
    document.getElementById('replyForm').style.display = 'block';
    document.getElementById('replyContent').focus();
}

// éšè—å›å¤è¡¨å•
function hideReplyForm() {
    document.getElementById('replyForm').style.display = 'none';
    document.getElementById('quoteId').value = '';
    document.getElementById('replyContent').value = '';
}

// å¼•ç”¨å›å¤
function quoteReply(replyId, cookieDisplay) {
    document.getElementById('quoteId').value = replyId;
    showReplyForm();
    const content = document.getElementById('replyContent');
    content.focus();
}

// æäº¤å›å¤
document.getElementById('submitReplyForm').addEventListener('submit', async function(e) {
    e.preventDefault();
    
    const formData = new FormData(this);
    
    try {
        const response = await fetch(`/api/threads/{{ thread.id }}/replies`, {
            method: 'POST',
            body: formData
        });
        
        const result = await response.json();
        
        if (result.success) {
            location.reload(); // åˆ·æ–°é¡µé¢æ˜¾ç¤ºæ–°å›å¤
        } else {
            alert(result.error || 'å›å¤å¤±è´¥');
        }
    } catch (error) {
        console.error('Error:', error);
        alert('ç½‘ç»œé”™è¯¯ï¼Œè¯·é‡è¯•');
    }
});

// å›¾ç‰‡é¢„è§ˆ
document.getElementById('replyImage').addEventListener('change', function(e) {
    const file = e.target.files[0];
    const preview = document.getElementById('replyImagePreview');
    
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            preview.innerHTML = `<img src="${e.target.result}" alt="é¢„è§ˆ">`;
        };
        reader.readAsDataURL(file);
    } else {
        preview.innerHTML = '';
    }
});

// è‡ªåŠ¨åˆ·æ–°å›å¤åŠŸèƒ½
class ReplyAutoRefresh {
    constructor(threadId) {
        this.threadId = threadId;
        this.refreshInterval = 20000; // 20ç§’æ£€æŸ¥ä¸€æ¬¡
        this.lastReplyId = {{ replies[-1].id if replies else 0 }};
        this.isRefreshing = false;
        this.isPageVisible = true;
        this.intervalId = null;
        
        this.init();
    }
    
    init() {
        // é¡µé¢å¯è§æ€§æ£€æµ‹
        document.addEventListener('visibilitychange', () => {
            this.isPageVisible = !document.hidden;
            if (this.isPageVisible) {
                this.checkForNewReplies();
            }
        });
        
        // å¯åŠ¨å®šæ—¶æ£€æŸ¥
        this.startAutoRefresh();
    }
    
    startAutoRefresh() {
        this.intervalId = setInterval(() => {
            if (this.isPageVisible && !this.isRefreshing) {
                this.checkForNewReplies();
            }
        }, this.refreshInterval);
    }
    
    stopAutoRefresh() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    
    async checkForNewReplies() {
        if (this.isRefreshing) return;
        
        this.isRefreshing = true;
        
        try {
            const response = await fetch(`/api/threads/${this.threadId}/replies/latest?last_id=${this.lastReplyId}`);
            const data = await response.json();
            
            if (data.success && data.has_new_content && data.replies.length > 0) {
                this.showNewRepliesNotification(data.replies.length);
                this.lastReplyId = data.latest_reply_id;
            }
        } catch (error) {
            console.error('æ£€æŸ¥æ–°å›å¤å¤±è´¥:', error);
        } finally {
            this.isRefreshing = false;
        }
    }
    
    showNewRepliesNotification(count) {
        const notification = document.getElementById('newRepliesNotification');
        const message = document.getElementById('newRepliesMessage');
        if (notification && message) {
            message.textContent = `ğŸ’¬ æœ‰ ${count} ä¸ªæ–°å›å¤ï¼Œç‚¹å‡»æŸ¥çœ‹`;
            notification.style.display = 'block';
        }
    }
    
    hideNewRepliesNotification() {
        const notification = document.getElementById('newRepliesNotification');
        if (notification) {
            notification.style.display = 'none';
        }
    }
}

// åˆ·æ–°å›å¤åˆ—è¡¨
async function refreshReplies(force = false) {
    const autoRefresh = window.replyAutoRefresh;
    if (!autoRefresh) return;
    
    if (force) {
        autoRefresh.hideNewRepliesNotification();
        window.location.reload();
        return;
    }
    
    autoRefresh.checkForNewReplies();
}

// åˆå§‹åŒ–å›å¤è‡ªåŠ¨åˆ·æ–°
document.addEventListener('DOMContentLoaded', () => {
    window.replyAutoRefresh = new ReplyAutoRefresh({{ thread.id }});
});

// é¡µé¢å¸è½½æ—¶æ¸…ç†å®šæ—¶å™¨
window.addEventListener('beforeunload', () => {
    if (window.replyAutoRefresh) {
        window.replyAutoRefresh.stopAutoRefresh();
    }
});
</script>
{% endblock %} 